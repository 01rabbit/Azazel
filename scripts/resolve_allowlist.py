#!/usr/bin/env python3
"""Resolve medical FQDN allowlist entries into nftables CIDRs."""
from __future__ import annotations

import argparse
import ipaddress
import socket
from pathlib import Path
from typing import Iterable, List, Set

import yaml


DEFAULT_CONFIG = Path("configs/azazel.yaml")
DEFAULT_OUTPUT = Path("build/generated/lockdown_allowlist.nft")


def load_config(path: Path) -> dict:
    data = yaml.safe_load(path.read_text())
    if not isinstance(data, dict):  # pragma: no cover - defensive guard
        raise ValueError("Configuration root must be a mapping")
    return data


def resolve_fqdns(fqdns: Iterable[str]) -> Set[ipaddress._BaseAddress]:
    results: Set[ipaddress._BaseAddress] = set()
    for fqdn in fqdns:
        try:
            infos = socket.getaddrinfo(fqdn, None)
        except socket.gaierror:
            continue
        for info in infos:
            ip_str = info[4][0]
            try:
                results.add(ipaddress.ip_address(ip_str))
            except ValueError:
                continue
    return results


def render_allowlist(cidrs: Iterable[str]) -> str:
    ipv4: List[str] = []
    ipv6: List[str] = []
    for item in sorted(set(cidrs)):
        network = ipaddress.ip_network(item, strict=False)
        if network.version == 4:
            ipv4.append(str(network))
        else:
            ipv6.append(str(network))

    def format_set(name: str, addr_type: str, values: List[str]) -> str:
        if values:
            elements_line = f"    elements = {{ {', '.join(values)} }}"
        else:
            elements_line = "    elements = {}"
        return (
            f"set {name} {{\n"
            f"    type {addr_type}\n"
            f"    flags interval\n"
            f"{elements_line}\n"
            f"}}"
        )

    parts = [
        "# Generated by resolve_allowlist.py",
        format_set("medical_allow_v4", "ipv4_addr", ipv4),
        format_set("medical_allow_v6", "ipv6_addr", ipv6),
    ]
    return "\n\n".join(parts)


def build_cidrs(config: dict) -> List[str]:
    qos = config.get("qos", {})
    medical = qos.get("medical", {})
    fqdns = medical.get("dest_fqdns", []) or []
    cidrs: Set[str] = set(medical.get("dest_cidrs", []) or [])

    resolved = resolve_fqdns(fqdns)
    for ip in resolved:
        prefix = 32 if ip.version == 4 else 128
        cidrs.add(f"{ip}/{prefix}")
    return sorted(cidrs)


def main() -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--config", type=Path, default=DEFAULT_CONFIG, help="Path to azazel.yaml")
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT,
        help="Destination nftables allowlist file",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print the generated allowlist while still refreshing the output file",
    )
    args = parser.parse_args()

    config = load_config(args.config)
    cidrs = build_cidrs(config)
    output_path = args.output

    if not cidrs:
        if output_path.exists():
            print("No CIDRs resolved; keeping existing allowlist")
            return 0
        raise SystemExit("No CIDRs available for lockdown allowlist")

    content = render_allowlist(cidrs)
    if args.dry_run:
        print(content)

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content + "\n", encoding="utf-8")
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())
